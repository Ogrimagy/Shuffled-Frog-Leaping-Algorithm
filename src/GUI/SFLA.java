/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package GUI;

import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 *
 * @author PC-GAMER
 */
public class SFLA {

    private Frog Xg, Xb, Xw, Xn, Xf; // Xg: Best frog over the population, Xb: Best Frog for each memplexe, Xw: Worst frog for each memplexe, Xn: New Frog generated by 2 equations, Xf: Optimal Solution.
    private HashMap<Integer, Frog> map; // Hashmap for the population
    private HashMap<Integer, Frog>[] memplexe; // Table of Hashmap for memplexes
    private double p1, p2;

    // Step 1: Set the size F of population, the number M of memeplex and the number N of iterations.
    public SFLA(HashMap map, double p1, double p2) {
//        System.out.println("Step 1: Set the size F of population, the number M of memeplex and the number N of iterations.");
        this.map = map;
        memplexe = new HashMap[Cloud.getM()];
//        System.out.println("F = " + Cloud.getF() + ", M = " + Cloud.getM() + ", N = " + Cloud.getN());
        this.p1 = p1/100;
        this.p2 = p2/100;
    }

    // Step 2: Generate a random population of F solutions and evaluate each solution.
    public void gen_frogs() { // Generates a random frog population from gaussian normal distribution. Sigma and Mu for the gaussian distribution.
//        System.out.println("\nStep 2: Generate a random population of F solutions and evaluate each solution.");
        optimize(map);
//        map.forEach((key, value) -> System.out.println("[Frog_id : " + key + ", Objective Value :" + map.get(key).getTotal() + "]"));
    }

    // Step 3: Sort the population and determine the best solution Xg.
    public void sort_frogs() {
//        System.out.println("\nStep 3: Sort the population and determine the best solution Xg.");
        map = sortValues(map);
//        map.forEach((key, value) -> System.out.println("[Frog_id : " + key + ", Objective Value :" + map.get(key).getTotal() + "]"));
        Xg = map.get(map.keySet().toArray()[0]);
//        System.out.println("The best solution is Xg : [Frog_id : " + Xg.getId_frog() + ", Objective Value :" + Xg.getTotal() + "]");
    }

    // Step 4: Partition the population into M memeplexes.
    public void part_frogs() {
        // initializing
        for (int i = 0; i < Cloud.getM(); i++) {
            memplexe[i] = new HashMap<>();
        }
        // Fill the memplexes
        int i = 0;
        for (Map.Entry<Integer, Frog> set : map.entrySet()) {
            memplexe[i].put(set.getKey(), set.getValue());
            i++;
            if (i == Cloud.getM()) {
                i = 0;
            }
        }
        // print the memplexes
//        System.out.println("\nStep 4: Partition the population into M memeplexes.");
        for (int k = 0; k < Cloud.getM(); k++) {
            memplexe[k] = sortValues(memplexe[k]);
            for (Map.Entry<Integer, Frog> set : memplexe[k].entrySet()) {
//                System.out.println("Memplexe[" + k + "] : [Frog_id : " + set.getKey() + ", Objective Value :" + memplexe[k].get(set.getKey()).getTotal() + "]");
            }
        }
    }

    // Step 5: Local search: for each memeplex, repeat for N iterations.
    public void local_search() {
//        System.out.println("\nStep 5: Local search: for each memeplexe, repeat for N iterations.");
        for (int i = 0; i < Cloud.getM(); i++) {
            for (int j = 0; j < Cloud.getN(); j++) {

                optimize(memplexe[i]);
                memplexe[i] = sortValues(memplexe[i]);

                // Step 5.1: Determine the best solution Xb and the worst solution Xw
                int length = memplexe[i].size();
                Xb = memplexe[i].get(memplexe[i].keySet().toArray()[0]);
                Xw = memplexe[i].get(memplexe[i].keySet().toArray()[length - 1]);

                // Step 5.2: Calculate Xw'(Xn) from Xb  (apply equations 1 and 2)
                Xn = generateFrog(Xb, Xw);
                HashMap<Integer, Frog> selectBestFrog_1 = new HashMap();
                selectBestFrog_1.put(1, Xn);
                selectBestFrog_1.put(2, Xw);
                optimize(selectBestFrog_1);
                /*System.out.println("Memplexe[" + i + "] = "
                        + "{Xw} : [Frog_id : " + Xw.getId_frog() + ", Objective Value :" + Xw.getTotal() + "], "
                        + "{Xn} : [Frog_id : " + Xn.getId_frog() + ", Objective Value :" + Xn.getTotal()+ "]");*/

                // Step 5.3: if (Xw'(Xn) is better than Xw) then replace Xw by Xw'(Xn)
                if (Xn.getTotal() < Xw.getTotal()) {
                    memplexe[i].replace(Xw.getId_frog(), Xn);

                } //Step 5.4: else calculate Xw'(Xn) from Xg (apply equations 1 and 2 with replacing Xb by Xg)
                else {
                    Xn = generateFrog(Xg, Xw);
                    HashMap<Integer, Frog> selectBestFrog_2 = new HashMap();
                    selectBestFrog_2.put(1, Xn);
                    selectBestFrog_2.put(2, Xw);
                    optimize(selectBestFrog_2);
                    if (Xn.getTotal() < Xw.getTotal()) {
                        memplexe[i].replace(Xw.getId_frog(), Xn);
                    } else {
                        Frog frog = new Frog(Xw.getId_frog());
                        memplexe[i].replace(Xw.getId_frog(), frog);
                    }
                }
            }
        }
    }
    
    // Step 6: Bring together the M memeplexes to build again the population.
    public void collect_memeplexes() {
//        System.out.println("\nStep 6: Bring together the M memeplexes to build again the population.");
        map.clear();
        for (int i = 0; i < Cloud.getM(); i++) {
            map.putAll(memplexe[i]);
        }
        optimize(map);
//        map.forEach((key, value) -> System.out.println("[Frog_id : " + key + ", Objective Value :" + map.get(key).getTotal() + "]"));
    }

    // Step 7: Go to step 3 if the stop criterion is not reached.
    public void repeat() {
//        System.out.println("\nStep 7: Go to step 3 if the stop criterion is not reached.");
    }

    // Step 8 : Determine the optimal solution
    public void opt_sol() {
//        System.out.println("\nStep 8 : Determine the best solution");
        map = sortValues(map);
        Xf = map.get(map.keySet().toArray()[0]);
//        System.out.println("The best solution is frog : [Frog_id : " + Xf.getId_frog() + ", Objective Value :" + Xf.getTotal() + "]");
//        Xf.getMap().forEach((key, value) -> System.out.println("Task " + key + " in the VM " + value));
    }

    private Frog generateFrog(Frog bestFrog, Frog worstFrog) { //map to fill the total value of new frog
        int tab[] = new int[Cloud.getCloudlet().length];
        for (int i = 0; i < tab.length; i++) {
            do {
                tab[i] = (int) (worstFrog.getTab()[i] + (Math.random() * Math.abs(bestFrog.getTab()[i] - worstFrog.getTab()[i])));
            } while (!(0 <= tab[i] && tab[i] < Cloud.getVm().length));
        }
        Frog newFrog = new Frog(worstFrog.getId_frog(), tab);
        return newFrog;
    }

    private HashMap sortValues(HashMap map) {
        List list = new LinkedList(map.entrySet());
        //Custom Comparator  
        Collections.sort(list, new Comparator() {
            public int compare(Object o1, Object o2) {
                return ((Comparable) ((Frog) ((Map.Entry) (o1)).getValue()).getTotal()).compareTo(((Frog) ((Map.Entry) (o2)).getValue()).getTotal());
            }
        });
        //copying the sorted list in HashMap to preserve the iteration order  
        HashMap sortedHashMap = new LinkedHashMap();
        for (Iterator it = list.iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry) it.next();
            sortedHashMap.put(entry.getKey(), entry.getValue());
        }
        return sortedHashMap;
    }

    private void optimize(HashMap<Integer, Frog> map) {
        double sumMakespan = 0;
        double sumCost = 0;
        for (Map.Entry<Integer, Frog> entry : map.entrySet()) {
            sumMakespan += entry.getValue().getMakespan();
            sumCost += entry.getValue().getCost();
        }
        for (Map.Entry<Integer, Frog> entry : map.entrySet()) {
            
            double total = ((entry.getValue().getMakespan()/sumMakespan)*p1)+((entry.getValue().getCost()/sumCost)*p2);
            entry.getValue().setTotal(total);
            
            entry.getValue().setM(entry.getValue().getMakespan());
            entry.getValue().setC(entry.getValue().getCost());
            
            entry.getValue().setMs(entry.getValue().getMakespan()/sumMakespan);
            entry.getValue().setCs(entry.getValue().getCost()/sumCost);
        }
    }

    public Frog start() {
        gen_frogs();
        for (int i = 0; i < Cloud.getS(); i++) {
            sort_frogs();
            part_frogs();
            local_search();
            collect_memeplexes();
            repeat();
        }
        opt_sol();
        return Xf;
    }
}
